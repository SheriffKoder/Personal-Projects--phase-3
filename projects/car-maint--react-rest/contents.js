
/*

Working with REST and React in the same time

1. need to look at the REST notes and (get the idea)                    1-2
2. need to look at the React App and (get the idea)                     1-2
3. need to (implement) the React app with the design and dummy data     3
4. need to (implement) the REST API app to work with the React code     4

Days to finish: 10 days 
Start date: 10/01 - 20/01
Expected duration: 11 days with (recap) 7 days without recap and first time


Section 24.0, 25(multer files, authentication) REST         [done reading / done reading]
section 26, async await -- Section 27, webSockets           [done reading / done reading]
Section 28, GraphQL                                         [done reading]
After: Section 29 Deploying, Section 31 Npm tools           [ //    / done reading]

REST with WebSockets
GraphQL version


*/




/*
////////////////////////////////////////////////////////////////////////////////////
REST, WebSockets, GraphQL, async/await / Npm


data to fill the user interfaces with life
view user-interface without refreshing the page based on the data fetched
backend to serve data

REST: representational state transfer, transfer data instead of user interfaces
a REST app works cross-platform (browsers, phones) because it sends the same data (json objects)

requests are sent as a combination (http method + server path) 
called API Endpoints, through routing as usual, 
this is done from the client side with script files (async code fetch/ajax), 
so we will define the logic on the server how it acts when receives a specific request, 

GET: get a resource from the server
POST: post as resource on the server (create or append resource)
PUT: put a resource onto the server (create or overwrite a resource)
PATCH: update parts of an resource on the server
DELETE: delete a resource on the server
OPTIONS: sent automatically on the browser to find out if the next request
    trying to do (e.g delete) if that is actually allowed
    determine whether follow-up request is allowed



your API should be predictable
and if open to the public should be well documented
> people should know what data your API expect
> which data your API sends back
> which endpoints do the API have

when building a REST API, the server and client are totally separated
they do not store any connection/common history
no session will be used or stored therefore
because every incoming request will be treated as no prior request
was sent, the server has a look at every request on its own
every request is handled separately
and a typical problem here is authentication
and we will solve this in the course

less important principles
3.a) Cashable principle
on the REST API you could send back some headers
that tells the client how long the response is valid
so that the client can cache the response

Requests and responses
- should attach data in the json format
and let the other end know by setting the content-type header
- express does this automatically when using json method
but on the browser it depends on which method you use
- when using axios, popular library for sending async requests
will be done automatically
- CORS errors

!! What is new to NextJS: fetch option's headers, CORS
!! We will implement authentication, file upload (storing a url string in the BD)

> add to the scripts in package.json to avoid ssl error
    "start": "react-scripts --openssl-legacy-provider start",


we will receive JSON as normal
we will send headers, with the method and body in the fetch
    fetch(url, {
      method: method, //"POST"
      headers: {
        "Content-type": "application/json"
      },
      body: JSON.stringify({
        //postData is an argument received in this function
        title: postData.title,
        content: postData.content
      })
    })


//How authentication work in a REST API
if user exists, a token with expiry is generated, hashed and sent to the user
the user should send it back in the headers contents with every request to access the DB
the backend will check on the validity of the token before taking action

in the past we checked that data on the server
and if it was valid, we established a session
we do not use sessions in REST APIs because the APIs are stateless

Server Token (with info) --> Client Browser
token sent back with every client request
"Token generated by an algorithm and private key not known to clients"
contains JSON and the generated signature
Token called JSON Web Token JWT

and this token will then be stored on the client
storage in the browser (there are specific storage mechanisms for this)

the client can then attach this token
to every subsequent request it sends to the server
!! for every request that targets a resource on the server
that requires authentication

that token can only be validated by the server
which created the token
and if tried to create that token on the front-end or fake it
that will be detected
because the server uses some algorithm
for generating the token
which you cant fake because you do not know 
the private key used by that server for generating the token

that token contains 
. JSON data
. signature (generated on the server with a special private key which is only stored on the server)
and this gives us a "JSON Web Token JWT"

this "JSON Web Token JWT" is then returned to the client
and the signature can only be verified by the server

tokens can be stolen if someone accessed the user's pc 
and found the user's token
however it will be expired after 1h as we stated in the controller

//using and validating the token
make sure the user can pass back the token to the rest api
and check for a. existence, b. validity of the token
before we allow the request to continue

>> in the FE > feed.js loadPosts
how can we include web tokens
that could be in the fetch url as a query parameter
we could attach it in the body,
!!!!!
but get requests have no body
a great solution is to use a header
headers make the urls neat and can attach some meta info in it
> add 2nd argument to the url as headers, authorization, props.token
!!!!!


////////////////////////////////////////////////////////////////////////////////////
Section 27 webSocket request protocol / socket.io library
//now what if something happens on the server and want to actively inform the client
ex. in a chat, user A sends a message to server and receives a response
but user B does not send a request to the server asking for the message
""by Pushing data to the client without a request""
by .emit (connected users) or .broadcast (all)

-- we can push by web sockets the next reminder to the client automatically
-- we can make a virtual chat ?


////////////////////////////////////////////////////////////////////////////////////
//Section 28: GraphQL (REST API with higher flexibility)
a rich query language that you use
in your front end to send it to the back end
which is parsed on the backend
""and retrieves just the data you need""



it is a normal Node (+Express) Server
we have ONE Single endpoint, typically /graphql

you only use POST requests (post for getting data? here yes)
because you can put the query expression into the request body

and you have resolvers on the server-side
that analyzes request body then do something with your data
based on the query expression you had in that body

and we will use third party packages for that parsing
and will have no more routes, we will use GraphQL, endpoints instead


for POST > send in the fetch body a query expression
to define the data that should be returned

for GET > you only send one kind of request to the server
that is a POST to /graphql

>> A GraphQL Query looks like

{
    query {
            user {
                name
                age
            }
    }
}
types/definitions of query:
query is equivalent to Retrieve data "GET"
Mutation is equivalent to Manipulate Data "POST" "PUT", "PATCH", "DELETE"
Subscription > setting up realtime connection via WebSockets

these queries are connected to resolvers
which contain the server-side logic

compared to a REST API
definitions would be like Routes
and resolvers would be like Controllers

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


async/await:
callbacks are another way to use async operations
instead of then
but they rely on un-ordered nesting
which will produce an un-readable code

so promises is preferred as it runs one then block after another
and it is very readable
still will be more readable with async and await

to async await getPosts controller in feed.js

starting with node v14.3

can use the await keyword also outside the async function
feature called "top-level-await"

mongoose operations like countDocuments, find()
does not return a real promise
but a promise like object
and you can use on them async/await
even though they are not a real promise

you can get back a real promise
by chaining .exec() after the mongoose operation

but in the bcrypt hash uses a real promise




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#npm help
get instructions about the available commands you may run

#npm install --help or npm install -h
get instructions about a specific command
how to run this command
what options we have to add additional flags


react merges all the code and transform into a format can run on all browsers
that is also minified and optimized

other dependencies like webpack
which orchestrate your build workflow, compile your different files
(your source code) parse them, pull all code together, rewrite code in supported syntax
these methods are done with packages behind the scenes which are used by npm
and then the code in these packages is executed through node js
unlock next gen features and handle them correctly using other tools
like babel

we can tell we are using node js there
by seeing the different import/export syntax from ES's
const webpack = require ("webpack");
instead of 
import { file }



*/




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//React notes
/*
mainly till hour 5
hour 6 deploying


as React uses camelCase property naming
for example class becomes className in JSX, and tabindex becomes tabIndex.
React component names must start with a capital letter, like StatusBar
Hook names must start with use followed by a capital letter, like useState


Redux: prevent having to pass props through multiple levels of the component tree

components must be "pure" functions
i.e return value based on input and not change something from outside
same output when the same inputs are passed


//component use
<Panel title="About" isActive={activeIndex === 0} onShow={() => setActiveIndex(0)} >
    With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
</Panel>

//component define
function Panel({title,children,isActive,onShow}: {name:type, name:type, name:type, name:type}) {
  return (
    <p>{children}</p> //children should be the text "With a population..." ?
  )
}

useReducer is very similar to useState, 
but it lets you move the state update logic from event handlers 
into a single function outside of your component.

*/


////////////////////////////////////////////////////////////////////////////////////
//Setup
/*
create a new react app with typescript support
# npx create-react-app my-app-name --template typescript
npm install -D tailwindcss
npx tailwindcss init
# npm start

Tailwind: 3.Configure your template paths 4.Add the Tailwind directives to your CSS
Run your build process with npm run start.
Start using Tailwind’s utility classes to style your content.


install the styled components and its types
npm i styled-components @types/styled-components

install react router and its types
npm i history react-router-dom @types/react-router-dom


the create-react-app with typescript bootstraps the project with configurations in tsconfig.json

*/

////////////////////////////////////////////////////////////////////////////////////
//Typescript
/*

//Movie will be a defined type, results an array of elements of type type Movie
export type Movies = {
  page: number;
  results: Movie[];
  total_pages: number;
  total_results: number
  
};

//if all the properties in a type are same type
export type Cast = {
    //property of string will be type of string
  [property: string]: string;

}


to ignore a line-warning in .ts file, type in the line before it
// @ts-ignore

//component of type react functional component
const App: React.FC = () => (

//results is an empty array but should be interpreted as a Movie array
    results: [] as Movie[],

//callback is a function that does not return anything
type Props = {
    text: string;
    callback: () => void;
    children: React.ReactNode;
}

//react function component with props of type Props
//define what the prop object will look like
const Button: React.FC<Props> = ({ text, callback }) => (

//this is a callback but what is the type ?
//if we hovered on the setSearchTerm in Home.tsx we will get its type
type Props = {
    setSearchTerm: React.Dispatch<React.SetStateAction<string>>;
}

*/



/*
//// Part 1
Project setup
# npx create-react-app my-app-name --template typescript
npm install -D tailwindcss
npm i styled-components @types/styled-components
npm i history react-router-dom @types/react-router-dom

add the typescript code to the index.css and tailwind.config.js

npm run start

you will leave any index. file and will work on the App.tsx
working on the App.tsx with tailwind



/////////////////////////////////////////////
//// Part 2

add components

the App.tsx is just a component
that returns a div
inside this div will put some other components like next-js

put the nav
-- put the footer

then put the home component which will be "/" 
which will include the CarInfo, checkCard etc


`
*/