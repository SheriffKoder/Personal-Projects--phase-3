
/*

Working with REST and React in the same time

1. need to look at the REST notes and (get the idea)                    1-2
2. need to look at the React App and (get the idea)                     1-2
3. need to (implement) the React app with the design and dummy data     3
4. need to (implement) the REST API app to work with the React code     4

Days to finish: 10 days 
Start date: 10/01 - 20/01
Expected duration: 11 days with (recap) 7 days without recap and first time


Section 24.0, 25(multer files, authentication) REST         [done reading / done reading]
section 26, async await -- Section 27, webSockets           [done reading / done reading]
Section 28, GraphQL                                         [done reading]
After: Section 29 Deploying, Section 31 Npm tools           [ //    / done reading]

REST with WebSockets
GraphQL version


*/




/*
////////////////////////////////////////////////////////////////////////////////////
REST, WebSockets, GraphQL, async/await / Npm


data to fill the user interfaces with life
view user-interface without refreshing the page based on the data fetched
backend to serve data

REST: representational state transfer, transfer data instead of user interfaces
a REST app works cross-platform (browsers, phones) because it sends the same data (json objects)

requests are sent as a combination (http method + server path) 
called API Endpoints, through routing as usual, 
this is done from the client side with script files (async code fetch/ajax), 
so we will define the logic on the server how it acts when receives a specific request, 

GET: get a resource from the server
POST: post as resource on the server (create or append resource)
PUT: put a resource onto the server (create or overwrite a resource)
PATCH: update parts of an resource on the server
DELETE: delete a resource on the server
OPTIONS: sent automatically on the browser to find out if the next request
    trying to do (e.g delete) if that is actually allowed
    determine whether follow-up request is allowed



your API should be predictable
and if open to the public should be well documented
> people should know what data your API expect
> which data your API sends back
> which endpoints do the API have

when building a REST API, the server and client are totally separated
they do not store any connection/common history
no session will be used or stored therefore
because every incoming request will be treated as no prior request
was sent, the server has a look at every request on its own
every request is handled separately
and a typical problem here is authentication
and we will solve this in the course

less important principles
3.a) Cashable principle
on the REST API you could send back some headers
that tells the client how long the response is valid
so that the client can cache the response

Requests and responses
- should attach data in the json format
and let the other end know by setting the content-type header
- express does this automatically when using json method
but on the browser it depends on which method you use
- when using axios, popular library for sending async requests
will be done automatically
- CORS errors

!! What is new to NextJS: fetch option's headers, CORS
!! We will implement authentication, file upload (storing a url string in the BD)

> add to the scripts in package.json to avoid ssl error
    "start": "react-scripts --openssl-legacy-provider start",


we will receive JSON as normal
we will send headers, with the method and body in the fetch
    fetch(url, {
      method: method, //"POST"
      headers: {
        "Content-type": "application/json"
      },
      body: JSON.stringify({
        //postData is an argument received in this function
        title: postData.title,
        content: postData.content
      })
    })


//How authentication work in a REST API
if user exists, a token with expiry is generated, hashed and sent to the user
the user should send it back in the headers contents with every request to access the DB
the backend will check on the validity of the token before taking action

in the past we checked that data on the server
and if it was valid, we established a session
we do not use sessions in REST APIs because the APIs are stateless

Server Token (with info) --> Client Browser
token sent back with every client request
"Token generated by an algorithm and private key not known to clients"
contains JSON and the generated signature
Token called JSON Web Token JWT

and this token will then be stored on the client
storage in the browser (there are specific storage mechanisms for this)

the client can then attach this token
to every subsequent request it sends to the server
!! for every request that targets a resource on the server
that requires authentication

that token can only be validated by the server
which created the token
and if tried to create that token on the front-end or fake it
that will be detected
because the server uses some algorithm
for generating the token
which you cant fake because you do not know 
the private key used by that server for generating the token

that token contains 
. JSON data
. signature (generated on the server with a special private key which is only stored on the server)
and this gives us a "JSON Web Token JWT"

this "JSON Web Token JWT" is then returned to the client
and the signature can only be verified by the server

tokens can be stolen if someone accessed the user's pc 
and found the user's token
however it will be expired after 1h as we stated in the controller

//using and validating the token
make sure the user can pass back the token to the rest api
and check for a. existence, b. validity of the token
before we allow the request to continue

>> in the FE > feed.js loadPosts
how can we include web tokens
that could be in the fetch url as a query parameter
we could attach it in the body,
!!!!!
but get requests have no body
a great solution is to use a header
headers make the urls neat and can attach some meta info in it
> add 2nd argument to the url as headers, authorization, props.token
!!!!!


////////////////////////////////////////////////////////////////////////////////////
Section 27 webSocket request protocol / socket.io library
//now what if something happens on the server and want to actively inform the client
ex. in a chat, user A sends a message to server and receives a response
but user B does not send a request to the server asking for the message
""by Pushing data to the client without a request""
by .emit (connected users) or .broadcast (all)

-- we can push by web sockets the next reminder to the client automatically
-- we can make a virtual chat ?


////////////////////////////////////////////////////////////////////////////////////
//Section 28: GraphQL (REST API with higher flexibility)
a rich query language that you use
in your front end to send it to the back end
which is parsed on the backend
""and retrieves just the data you need""



it is a normal Node (+Express) Server
we have ONE Single endpoint, typically /graphql

you only use POST requests (post for getting data? here yes)
because you can put the query expression into the request body

and you have resolvers on the server-side
that analyzes request body then do something with your data
based on the query expression you had in that body

and we will use third party packages for that parsing
and will have no more routes, we will use GraphQL, endpoints instead


for POST > send in the fetch body a query expression
to define the data that should be returned

for GET > you only send one kind of request to the server
that is a POST to /graphql

>> A GraphQL Query looks like

{
    query {
            user {
                name
                age
            }
    }
}
types/definitions of query:
query is equivalent to Retrieve data "GET"
Mutation is equivalent to Manipulate Data "POST" "PUT", "PATCH", "DELETE"
Subscription > setting up realtime connection via WebSockets

these queries are connected to resolvers
which contain the server-side logic

compared to a REST API
definitions would be like Routes
and resolvers would be like Controllers

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////


async/await:
callbacks are another way to use async operations
instead of then
but they rely on un-ordered nesting
which will produce an un-readable code

so promises is preferred as it runs one then block after another
and it is very readable
still will be more readable with async and await

to async await getPosts controller in feed.js

starting with node v14.3

can use the await keyword also outside the async function
feature called "top-level-await"

mongoose operations like countDocuments, find()
does not return a real promise
but a promise like object
and you can use on them async/await
even though they are not a real promise

you can get back a real promise
by chaining .exec() after the mongoose operation

but in the bcrypt hash uses a real promise




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

#npm help
get instructions about the available commands you may run

#npm install --help or npm install -h
get instructions about a specific command
how to run this command
what options we have to add additional flags


react merges all the code and transform into a format can run on all browsers
that is also minified and optimized

other dependencies like webpack
which orchestrate your build workflow, compile your different files
(your source code) parse them, pull all code together, rewrite code in supported syntax
these methods are done with packages behind the scenes which are used by npm
and then the code in these packages is executed through node js
unlock next gen features and handle them correctly using other tools
like babel

we can tell we are using node js there
by seeing the different import/export syntax from ES's
const webpack = require ("webpack");
instead of 
import { file }



*/




////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//React notes
/*
mainly till hour 5
hour 6 deploying


as React uses camelCase property naming
for example class becomes className in JSX, and tabindex becomes tabIndex.
React component names must start with a capital letter, like StatusBar
Hook names must start with use followed by a capital letter, like useState


Redux: prevent having to pass props through multiple levels of the component tree

components must be "pure" functions
i.e return value based on input and not change something from outside
same output when the same inputs are passed


//component use
<Panel title="About" isActive={activeIndex === 0} onShow={() => setActiveIndex(0)} >
    With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
</Panel>

//component define
function Panel({title,children,isActive,onShow}: {name:type, name:type, name:type, name:type}) {
  return (
    <p>{children}</p> //children should be the text "With a population..." ?
  )
}

useReducer is very similar to useState, 
but it lets you move the state update logic from event handlers 
into a single function outside of your component.

*/


////////////////////////////////////////////////////////////////////////////////////
//Setup
/*
create a new react app with typescript support
# npx create-react-app my-app-name --template typescript
npm install -D tailwindcss
npx tailwindcss init
# npm start

Tailwind: 3.Configure your template paths 4.Add the Tailwind directives to your CSS
Run your build process with npm run start.
Start using Tailwindâ€™s utility classes to style your content.


install the styled components and its types
npm i styled-components @types/styled-components

install react router and its types
npm i history react-router-dom @types/react-router-dom


the create-react-app with typescript bootstraps the project with configurations in tsconfig.json

*/

////////////////////////////////////////////////////////////////////////////////////
//Typescript
/*

//Movie will be a defined type, results an array of elements of type type Movie
export type Movies = {
  page: number;
  results: Movie[];
  total_pages: number;
  total_results: number
  
};

//if all the properties in a type are same type
export type Cast = {
    //property of string will be type of string
  [property: string]: string;

}


to ignore a line-warning in .ts file, type in the line before it
// @ts-ignore

//component of type react functional component
const App: React.FC = () => (

//results is an empty array but should be interpreted as a Movie array
    results: [] as Movie[],

//callback is a function that does not return anything
type Props = {
    text: string;
    callback: () => void;
    children: React.ReactNode;
}

//react function component with props of type Props
//define what the prop object will look like
const Button: React.FC<Props> = ({ text, callback }) => (

//this is a callback but what is the type ?
//if we hovered on the setSearchTerm in Home.tsx we will get its type
type Props = {
    setSearchTerm: React.Dispatch<React.SetStateAction<string>>;
}

*/



/*
//// Part 1
Project setup
# npx create-react-app my-app-name --template typescript
npm install -D tailwindcss
npm i styled-components @types/styled-components
npm i history react-router-dom @types/react-router-dom

add the typescript code to the index.css and tailwind.config.js

npm run start

you will leave any index. file and will work on the App.tsx
working on the App.tsx with tailwind



/////////////////////////////////////////////
//// Part 2

add components
the main layout (App.tsx) nav/footer, home component(s), history page + components

the App.tsx is just a component
that returns a div
inside this div will put some other components like next-js

put the nav
-- put the footer

then put the home component which will be "/" 
which will include the CarInfo, checkCard etc

in these components create the UI and fill with dummy data
working on the dummy data to determine the needed functionality

use useNavigate to live redirect

add the router wrapper in the main components App.tsx
to allow switching between pages still keep the nav/footer without reload
with the help of the useNavigate method


/////////////////////////////////////////////
//// Part 3

add a login/signup, add/edit check

//the login,signup component page
//the add maintenance

what should it have
name
color
id (backend)

addDate (backend)
initialCheck
nextCheck
checkedOn = later a route
notes
_id (backend, id+index)


so will have
title, color, 
initial check (should be moved to the head of the object)
next check
notes

when editing the initial check (previous default on 0) will check if there is one
if it exists (first check) then can edit
if not exist, (1st+ check, previous check will be based on the check before  
duration should be determined by today-next check

so the edit check component is exactly the same
all what i did is changed text and put a condition to view the initial check input

most probably the car edit will be like the new car component

/////////////////////////////////////////////
//// Part 3.1

add proper edit/delete buttons 
for add new check, edit/delete checks from home page and history page by passing references
edit a check from the home page (edit the currentCheck by its index in history which will be 0)
delete a check from the home page (delete the check tree)
edit a check from the history (edit the selected check by its index in history)
delete a check from the home page (delete the selected check by its index in history)

edit/add new car

add new car button and sign-out button on nav, when user is logged in

edit and add new car displays ? or mark depending on the image
add delete button if there is a car we are editing

/////////////////////////////////////////////
//// Part 3.2

responsively

home page

Work on the website buttons with proper redirection
- add-new-check
- edit/delete checks from history, should pass to their relevant functions the checkId, and the history item in question's index
- delete check from home page passes the id of the whole check tree to be deleted
- add/edit car from the nav/home page

Further Addons:
- Add icons that overlay the car's image when editing/adding a car
to represent the image status (no image/image uploaded)
- Add to all the components navigation links
- is a user is loggedIn, the login button is replaced with sign-out, add car buttons

Make the website responsive for all view-widths


/////////////////////////////////////////////
//// Part 4 Video notes

do not get confused, just understand topics like loading, etc.

notice:
React.CreateElement(Element, props, content)
in class components you can use only one state

the .svg files do have paths code
then can import it as an element into the code
and pass as a src prop to the styled component


useMemo/useCallback, used to call a function conditionally so 
in the case when using a function with a setState in a useEffect
that triggers a infinite loop of re-rendering


isLoading, just a state to show/hide spinner button

//keeping the old data and adding new beside it (load more)
setState(prev => ({
    ...movies,
    results: page > 1 ? [...prev.results, ...movies.results] : [...movies.results]
}))

2:53:40 , timer to set the search term to the search input every 500ms automatically
useEffect returns clearTimeout(timer)
that triggers on setSearchTerm, and searchInput


//skip the initial render in a useEffect
if (initial.current) { initial.current = false; return; }

3:01:00, search input transparent bg and absolute on a rounded div with padding
of for the div's search icon,

const { state: movie, loading } = someState; //name state as movie


react uses the key when mapping, to diff stuff to know what it will change in the DOM








//////// take away: ////////

//styled-components lib
component folder > Header.styles.tsx
import styled from "styled-components"
export const wrapper = styled.div`
  position: absolute;
  left: ${props.direction}
  @media () {}
  h1 {}
`;
""repeat
then import these const into the app.tsx/index.tsx etc.
<Wrapper direction={} />


the globalStyle.js file to set some basics for the root, body, definitions
and import its {const} in the App.tsx
and use this {const} as an element in the wrapping div


** //props and state /////////////////////////////////////////////
setLamp(prev => !prev); //you get the current state as a prop

<Lamp lampOn={isLampOneOn}
<LightSwitch switchOn={isLampOneOn} callBack={handleLamp}


take props as const Lamp = (props) => () then props.name
or ({name, age}), then name, age
//a prop should never change in the component that receives the prop
!! when the prop changes from the parent, the child component will re-render
and have a new value !

on many re-renders due to multiple setStates react diff the states 
will only update things in the DOM that have changed
so no performance issue
///////////////////////////////////////////////////////////////

//custom hooks
can be used for re-using logic
folder hooks > useHookName.tsx
export const useHookName = () => {
  put all the fetching logic and its state definitions
}
- custom hooks 3:36:30 [done] function with useEffect function and call


css: object-fit cover;
//for hero movie bg css
background-size:cover, background-position:center;
and over this an element with background 0, 0, 0, 0, 0.7


<input
onChange={(e) => setState(e.currentTarget.value)}
value={state}
/>


** helpers calc time and convert-money



//////// look at: ////////

- css grid

the useEffect cannot have an async keyword, [done]
so will use inside of it an async function
with try/catch, in the try can await
then call it

- useDeferredValue


** //route params /////////////////////////////////////////////
//give params
import {Link} from "react-router-dom";
and in the component
<Link to={`/${movieId}`}

//get params
import {useParams} from "react-router-dom";
const {movieId} = useParams();

movieId as defined in the route url in the layout
///////////////////////////////////////////////////////////////


//persist state in the session storage
if there is something in the session storage on initial render
retrieve this one instead



 
** //the context /////////////////////////////////////////////
which exports a userProvider function
in the root of the src context.js
context to provide down values
provider to provide the application with these values
the {children} to wrap any component in our application 
then wrap the components inside userProvider tags

in the login, import Context from the context.js
then
const [user, setUser] = useContext(Context)

ok, the Context is a useContext const
added on it .provider with value=[state,setState]
then the app is wrapped in it

in the login component, import the const Context, then destruct out the values 
(state, setState)
to set value for the setState/setUser on a successful login
thus. this context (state) which holds the user, can be used in all wrapped components

to use 
const [state] = useContext(Context);

wipe out the user from the state when log out
///////////////////////////////////////////////////////////////




-- we can use this to make a login component before the API
tomorrow revert thinking pattern
we apply these notes, sort them, 
and in the 2nd itr begin the REST notes


..
context, params
props read


*/



/////////////////////////////////////////////
//// Part 5 using context
/*

let us have a user context

ok so i can use the userContext values in the home components
carInfo and checkCards

- add a welcome page



create a context in context.tsx
>export the context wrapper with value of a state and a function that sets the state
>wrap the application in the context wrapper
add a separate component in the app.tsx for the routing (to use the context value)

> on any component, use the useContext(userContext) to access the context value
> on any component, use the useContext(userContext).updateUser

/////////////////////////////////////////////
////// Part 6 the backend

////API 0.1
let us check the backend... shall we

will use a process.env to store the API url as it can be changed
needs names to be defined as REACT_APP_VARNAME
and use it in react with a ! for overcoming the undefined error


> signUp.tsx
- add form input and submit functions and jsx attributes
- add fetch method and display the API's response and status

> login.tsx
- add form input and submit functions and jsx attributes
- add fetch method and display the API's response and status













/*




this project was designed mainly to work on phones and tablets in terms of UI
did not work much on the front-end functionalities
as the main idea is to practice making a REST App
and try working with plain react for learning purposes




*/